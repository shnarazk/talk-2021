\NeedsTeXFormat{LaTeX2e}
%\PassOptionsToClass{handout}{beamer}
\documentclass{beamer}
\usepackage{beamerPack}
\usepackage[boxed,ruled,vlined]{algorithm2e}
\usepackage[05]{../lecture}
\usepackage[usestackEOL]{stackengine}[2013-10-15]
\def\x{\hspace{4.1ex}}    %BETWEEN TWO 1-DIGIT NUMBERS
\def\y{\hspace{3.4ex}}  %BETWEEN 1 AND 2 DIGIT NUMBERS
\def\z{\hspace{2.7ex}}    %BETWEEN TWO 2-DIGIT NUMBERS
\subtitle{}
\begin{document}

\begin{frame}[fragile]{}
\titlepage
\end{frame}

\section{algorithm design}		%%%%%%%%
\subsection{}

\section{dynamic programming}		%%%%%%%%
\subsection{}

\begin{frame}[fragile]{動的計画法}{}

\begin{block}{動的計画法(dynamic programming)}
\begin{itemize}%\itemsep8pt
\item 再帰的に分割された部分問題の(最適)解から元問題の(最適)解を構成
\item 部分問題の重複性の利用
\end{itemize}
\end{block}

\footnotetext{線形計画法は不等式に関する問題}
\end{frame}


\begin{frame}[fragile]{アルゴリズムの改良}{素数}
a
\end{frame}

\begin{frame}[fragile]{アルゴリズムの改良}{フィボナッチ数}
a
\end{frame}

\begin{frame}[fragile]{問題の再帰構造の次元を落とす（線形化）}{}
a
\end{frame}


\begin{frame}[fragile]{帰納法とループ}{与えられた数式からプログラムへ}
\begin{align*}
Fib(0) =& 1\\
Fib(1) =& 1\\
Fib(n) =& Fib(n - 1) + Fib(n - 2)\\
\end{align*}

\begin{align*}
A(0, n) =& n + 1\\
A(m + 1, 0) =& A(m, 1)\\
A(m + 1, n + 1) =& A(m, A(m + 1, n))
\end{align*}
\end{frame}

\begin{frame}[fragile]{例題}{\herf{}{advent-of-code 2020}より}
\end{frame}


\begin{frame}[fragile]{メモ化}{\href{https://ja.wikipedia.org/wiki/メモ化}{\beamergotobutton{wikipedia}}}
\begin{codeof}{language=Rust}{メモ化の一般形}
fn foo (問題指定) -> 解の型 {
  static memo: Hash<問題指定の型, 解の型>;
  // メモの確認
  if memo[問題指定]が有効な値を持つ {
    return memo[問題指定];
  }

   本来の計算：問題指定から解を求める

  // メモする
  memo[問題指定] = 解;
  return 解;
}
\end{codeof}

\footnotetext[1]{定型化されているので言語によってはこのコードを自動生成する}
\end{frame}

\begin{frame}[fragile]{fibに対するメモ化の例}{\href{https://ja.wikipedia.org/wiki/メモ化}{\beamergotobutton{repl it}}}
\begin{codeof}{language=Rust}{fib (memo.rs)}
pub fn fib(n: usize) -> usize {
    if let Ok(hash) = MEMO.read() {
        if let Some(r) = hash.get(&n) {
            return *r;
        }
    }
    let n_1 = if n <= 2 { 1 } else { fib(n - 1) };
    let n_2 = if n <= 2 { 0 } else { fib(n - 2) };
    let result = n_1 + n_2;
    if let Ok(mut hash) = MEMO.write() {
        hash.insert(n, result);
    }
    result
}
\end{codeof}

\begin{spacing}{0.7}\fontsize{6}{6}\selectfont
メモは毎回初期化されないようグローバル(static)変数にしたい。
Rustではグローバル変数への操作は同期操作を使ったスレッド安全なものしか受け付けないので、
ライブラリのインポートや変数定義（ここでは省略）、アクセス(L.2--6, L.10-12)が面倒になっている。
\end{spacing}
\end{frame}

\begin{frame}[fragile]{効果の確認}{}

\begin{codeof}{language=Rust}{}
fn main() {
    let n = 46;
    // mainから1回しか呼ばなくても再帰しているのでメモ化は有効
    println!("fib({:>2}) = {:>11}", n, fib(n));
    println!("fib({:>2}) = {:>11}", n, slow_fib(n));
    // メモに残っているので同じ計算では2回目以降はO(1)
    for i in 30..=48 {
        println!("fib({:>2}) = {:>11}", n, fib(n));
        println!("slw({:>2}) = {:>11}", n, slow_fib(n));
    }
    // 引数が違ってもメモに残っているので新規分だけ計算
    for i in 30..=48 {
        println!("fib({:>2}) = {:>11}", i, fib(i));
        println!("slw({:>2}) = {:>11}", i, slow_fib(i));
    }
}
\end{codeof}
\end{frame}

\end{document}
