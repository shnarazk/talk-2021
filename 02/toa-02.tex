\NeedsTeXFormat{LaTeX2e}
%\PassOptionsToClass{handout}{beamer}
\documentclass{beamer}
\usepackage{beamerPack}
\usepackage[boxed,linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[02]{../lecture}
\subtitle{}
\begin{document}

\begin{frame}[fragile]{}
\titlepage
\end{frame}

\section{time \& space complexity}		%%%%%%%%
\subsection{}

\begin{frame}[fragile]{アルゴリズムの性能(資源消費）の評価尺度}{}
\begin{block}{時間計算量}
実行に必要な時間。ハードウェア依存性をなくすため絶対時間ではなく命令実行回数が単位。
\end{block}
\begin{block}{空間計算量}
その計算を実行するために必要なメモリ量。ただしデータそのものは含めないことが多い。
Byte数よりも個数が単位。
\end{block}
\end{frame}

\begin{frame}[fragile]{時間計算量}{}
\begin{block}{方針}
\begin{itemize}%\itemsep8pt
\item 命令(行)の実行回数で比較(実時間はハードウェア依存)
\item 最悪の場合を想定(平均は困難)
\item データの個数に依存するため、$N$の関数として表現
\end{itemize}
\end{block}

\begin{columns}
\begin{column}{0.7\textwidth}
\scalebox{0.8}{
\begin{algorithm}[H]
\KwIn{v: \texttt{Vec<T>}}
\KwIn{条件 --- 引数を二分判定する関数}
\KwOut{発見または失敗}
\SetKwComment{Comment}{}{}
i = 0\;
\While{iが要素数より小さい} {
  \If{v[i]が条件を満たす}{
    \Return{発見}
  }
  i += 1\;
}
\Return{失敗}\;
\caption[page]{線形探索}
\end{algorithm}
}
\end{column}
\begin{column}{0.25\textwidth}

\begin{itemize}%\itemsep8pt
\item L1: 1
\item L2: 最悪N
\item L3: 最悪N
\item L4: 1 or 0
\item L5: 最悪N
\item L6: 1 or 0
\end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{時間計算量の簡略化}{}
\begin{itemize}%\itemsep8pt
\item おそらく条件検査(L3)が１番時間が掛かる
\item L3とL5の実行回数はほぼ一緒
\item L3のif文を数えることに帰着させる（係数の差程度）
\end{itemize}

\vfill
\begin{columns}
\begin{column}{0.7\textwidth}
\scalebox{0.8}{
\begin{algorithm}[H]
\KwIn{v: \texttt{Vec<T>}}
\KwIn{条件 --- 引数を二分判定する関数}
\KwOut{発見または失敗}
\SetKwComment{Comment}{}{}
i = 0\;
\While{iが要素数より小さい} {
  \If{v[i]が条件を満たす}{
    \Return{発見}
  }
  i += 1\;
}
\Return{失敗}\;
\caption[page]{線形探索}
\end{algorithm}
}
\end{column}
\begin{column}{0.25\textwidth}
L3の実行回数はL2の実行回数。
最悪$N$回。

\medskip
線形探索の時間計算量は$N$。
データが増えると比例して時間が掛かる。

\medskip
計算上では。
\end{column}
\end{columns}
\end{frame}

\section{$O$-notation}		%%%%%%%%
\subsection{}

\begin{frame}[fragile]{より説明力を持たせたい}{}
\begin{itemize}\itemsep8pt
\item 理論的に求めた計算量が現実を説明しないかもしれない
\item あるいはN=100近辺で考える人とN=100,0000,000で考える人で違う印象を持つかもしれない
\item 重要なのはどんどんデータが増えていった時にどうなるかでは？ スケーラビリティ。
\item 極限は無限大に飛ばす操作なのでこの文脈では不適切
\end{itemize}
\end{frame}

\begin{frame}[fragile]{$O$-記法}{}
実数値関数 $f(x)$ と $g(x)$ に対し、

\begin{align*}
\exists x_{0}, \exists M > 0,  \forall x > x_{0} : |f(x)| < M | g(x) |
\end{align*}
が成立するとき（またその時に限り）、

\begin{align*}
f(x) &= O(g(x))
\end{align*}
\end{frame}

\begin{frame}[fragile]{足掛かり1}{}

実行時間（命令回数）の測定結果を表す$f(x)$と何か数学的な関数$g(x)$に対し、

\begin{align*}
適当に x_{0}と係数M > 0を決めたら & \\
x_{0}以上の範囲では& fより M g が大きい.
\end{align*}
ことがわかったら、

\begin{align*}
f(x) &= O(g(x))
\end{align*}
と書こう。
\end{frame}

\begin{frame}[fragile]{足掛かり2}{}

\begin{itemize}\itemsep20pt
\item 「データ数$100$で実験したら線形探索の方が速かったです」
\begin{itemize}
\item $x_{0} = 100$として考えれば騒ぐほどじゃないな
\end{itemize}
\item 「こっちのPCでは実験結果は$O(N^2)$、あっちのだと$O(2.4N^2)$になりました」
\begin{itemize}
\item $M=2.4$とおいたらどちらも同じなのに
\end{itemize}
\item なぜ絶対値
\begin{itemize}%\itemsep8pt
\item 時間測定に限定させない一般化（波のenvelop関数）
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{$O$-記法の解釈と例}{}

$f(x) = O(g(x))$なら$f$は$g$で上から抑えられる、すなわち上限

\begin{align*}
1.5 x & = O(x) \\
\sum_{1}^{n=N} n & = O(N^2) \\
0.001x^2 + 2000000x & = O(x^2 + x) \\
         & = O(x^2) \\
\end{align*}

\vfill
以下は間違い。近似関係ではなく等値関係。
\begin{align*}
2.14x^3 & \approx O(x^3)
\end{align*}
\end{frame}

\section{Order of search}		%%%%%%%%
\subsection{}

\begin{frame}[fragile]{線形探索の計算量}{}

\begin{itemize}\itemsep30pt
\item 線形探索の時間計算量は$O(N)$である。\footnotemark
\item 線形探索の空間計算量は$O(1)$である。\footnotemark
\end{itemize}

\footnotetext[1]{読み方色々：オー、ビッグオー、オーダーなど。}
\footnotetext[2]{ローカル変数を$X$個定義しても$X = O(1)$。}

\end{frame}

\begin{frame}[fragile]{$\Omega(-)$, $\Theta(-)$}{}
\begin{align*}
\exists x_{0}, \exists M > 0,  \forall x > x_{0} : |f(x)| > M | g(x) |
\end{align*}
が成立するとき（またその時に限り）、

\begin{align*}
f(x) &= \Omega(g(x))
\end{align*}

\vfill
\begin{align*}
f(x) = O(g(x)) && f(x) = \Omega(g(x))
\end{align*}
が成立するとき（またその時に限り）、

\begin{align*}
f(x) &= \Theta(g(x))
\end{align*}
\end{frame}

\begin{frame}[fragile]{二分探索の計算量}{}
\scalebox{0.7}{
\begin{algorithm}[H]
\SetKwComment{Comment}{}{}
\BlankLine
i = 0; j = z.len() - 1\Comment*{\sl\small\color[gray]{0.5}探索範囲}
\While{i <= j} {
  \If{ v[(i + j) / 2]が等しい}{
    \Return{発見}
  }
  \eIf{v[(i + j) / 2]が小さい}{
    i = (i + j) / 2 + 1\Comment*{\sl\small\color[gray]{0.5}探索範囲の左半分を破棄}
  }{
    j = (i + j) / 2 - 1\Comment*{\sl\small\color[gray]{0.5}探索範囲の右半分を破棄}
  }
}
\Return{失敗}\;
\caption[page]{二分探索}
\end{algorithm}
}

\vfill

\begin{itemize}%\itemsep8pt
\item データの大きさが$N$の場合の繰り返し回数\footnotemark: $\log_{2}(N)$
\item 各繰り返しの中で実行する条件比較は2回=$O(1)$回
\item ローカル変数が二つ
\end{itemize}
\end{frame}

\begin{frame}[fragile]{$\log_2(N)$の理由}{}

{%\fontsize{9}{10}\selectfont
\begin{tabular}[h]{|c|r| r |}
\CH $N$ & 範囲の(最悪)変化 & 繰返し回数 \\
\CL $1$ & $1$ & $1$ \\
\CL $3$ & $3 \to 1$ & $2$ \\
\CL $7$ & $7\to3\to1$ & $3$ \\
\CL $15$ & $15\to7\to3\to1$ & $4$ \\
\CL $2^x - 1$ & $2^{x} -1 \to 2^{x-1} - 1 \to \cdots \to 2^1 - 1$ & $x$ \\
\CL $N$ & -- & $\log_2(N)$ \\
\end{tabular}
}

\begin{align*}
Nに対する全体の計算量 & = 繰り返し回数 \times そこでの計算量 \\
& = \log_2(N) \times O(1)\\
& = O(\log(N))
\end{align*}
\end{frame}

\begin{frame}[fragile]{探索の計算量まとめ}{}

{%\fontsize{9}{10}\selectfont
\begin{tabular}[h]{|c|r|r|r|}
\CH アルゴリズム & （最悪）時間計算量 & 最良時間-- & 空間-- \\
\CL 線形探索 & $O(N)$ & $O(1)$ & $O(1)$ \\
\CL 二分探索 & $O(\log(N))$ & $O(1)$ & $O(1)$ \\
\end{tabular}
}
\end{frame}

\begin{frame}[fragile]{より速い探索}{}

\begin{block}{並列探索}
データをパーティショニング。固定のM台使用するなら$O(N/M) = O(N)$。
データの大きさに合わせて増加させるなら$O(N)$以下が可能。
\end{block}

\begin{block}{ハッシュ表とハッシュ関数}
\begin{itemize}%\itemsep8pt
\item 時間計算量は$O(1)$
\item 空間計算量は$O(データの潜在的総数)$
\end{itemize}
\end{block}

二分探索は速いが、計算量が大きな前処理が必要。なんとかならないか：赤黒木, tri-Tree, 3-4-5木などの〇〇木
\end{frame}
\end{document}
